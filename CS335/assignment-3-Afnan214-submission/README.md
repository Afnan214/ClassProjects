# Assignment-3-Code

Personally I found the code for this assignment was slightly more simpler than the one in the last assignment. It was easier to understand than the ones on trees. returning the number of elements, table size, load factor were all generally simple. In each of the h files I added in a num_elements, and num_collisions private class data members and manipulated them to return the proper value... add 1 to num_elements whenever a value is inserted or subtract 1 when a value is "removed" or "deleted". For table size it would just be the "array_" size. Returning the number of collisions is something I did after figuring out how to return the number of probes. At first I created a separate private class function very similar to the FindPos function called "num_probes" and instead of keeping it as a const function I changed it to pass a second parameter called probes to count the number of probes taken by finding the position again separately. So that would call FindPos(x) once to return the position of empty value or position of x, and then num_probes(x, probes) would be called to get the number of probes. This was however inefficient since the table is being searched twice as many times as needed. After completing all the tasks I just made it so FindPos(x) takes in two paramaters instead of one and the second parameter is an int to keep track probes and is passed by reference. This way the table is only being searched once and FindPos is able to both find the position and also tracks the number of probes taken to find the position.

The most difficult part of the assignment was probably getting double hashing to work. I didn't realize I was meant to modulus by the tablesize for the second hash function as well which caused some error. I also thought that the second hashfunction would start searching from a brand new position independent from the first hash function, however the second hashfunction could be seen as an offset which is added to the result of the first hash functions position. linear_probing.h and double_hashing.h were both otherwise pretty identical to quadratic probing. For linear_probing.h the only main difference was in FindPos where the offset was always a static value of 1 instead of increasing by 2 every probe as it did in quadratic_probing.h.

R_VALUES that were tested ... 89, 101, 55619, 66... I made it so that even with non prime R values the next prime number will be chosen to be the R_Value since if it is not a prime number it may cause an infinite loop when searching for elements.

For case_a in spell_check.cc I used brute force by adding one letter at a time of all 26 letters in each spot of the word, and each time check if the word can be found in the "dictionary"(hash table). case_b we would delete a letter from the word check if the word can be found, then add back the character. case_c we would just swap two consecutive characters, check if they can be found, and the swap them back.
